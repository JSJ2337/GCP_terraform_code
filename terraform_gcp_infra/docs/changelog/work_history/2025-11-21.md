# 2025-11-21 작업 내역

## 개요
50-workloads 레이어의 서브넷 자동화 구현 완료 및 Jenkinsfile Phase 기반 구조 전환. Mock outputs 참조 문제를 근본적으로 해결하기 위한 순차 배포 파이프라인 구축.

## 주요 변경사항

### 1. 50-workloads 서브넷 자동화 구현
**목적**: 10-network 레이어의 subnet outputs를 자동으로 참조하여 하드코딩 제거

#### 변경 내역
**이전 (하드코딩)**:
```hcl
# terraform.tfvars
"jsj-lobby-01" = {
  subnetwork_self_link = "projects/jsj-game-n/regions/asia-northeast3/subnetworks/game-n-subnet-dmz"
}
```

**변경 후 (subnet_type 기반 자동 참조)**:
```hcl
# terraform.tfvars
"jsj-lobby-01" = {
  subnet_type = "dmz"  # 10-network의 subnets["dmz"].self_link 자동 참조
}
```

#### 구현 상세
**50-workloads/terragrunt.hcl**:
```hcl
dependency "network" {
  config_path = "../10-network"

  mock_outputs = {
    subnets = {
      dmz     = { self_link = "mock-dmz-subnet", region = "asia-northeast3", project_id = "mock-project", name = "mock-dmz" }
      private = { self_link = "mock-private-subnet", ... }
      db      = { self_link = "mock-db-subnet", ... }
    }
  }

  mock_outputs_allowed_terraform_commands = ["init", "plan", "validate"]
}

inputs = merge(
  local.common_inputs,
  local.layer_inputs,
  {
    subnets = dependency.network.outputs.subnets
  }
)
```

**50-workloads/variables.tf**:
```hcl
variable "subnets" {
  type = map(object({
    self_link  = string
    region     = string
    project_id = string
    name       = string
  }))
  description = "10-network 레이어에서 가져온 서브넷 맵"
  default     = {}
}

variable "instances" {
  type = map(object({
    subnet_type = optional(string)  # "dmz", "private", "db"
    ...
  }))

  validation {
    condition = alltrue([
      for name, cfg in var.instances :
      cfg.subnet_type == null || contains(["dmz", "private", "db"], cfg.subnet_type)
    ])
    error_message = "subnet_type은 'dmz', 'private', 'db' 중 하나여야 합니다."
  }
}
```

**50-workloads/main.tf**:
```hcl
locals {
  processed_instances = {
    for name, cfg in var.instances :
    name => merge(
      { for k, v in cfg : k => v if k != "subnet_type" },
      try(cfg.subnet_type, null) != null ?
      { subnetwork_self_link = var.subnets[cfg.subnet_type].self_link } :
      {}
    )
  }
}
```

#### 영향
- ✅ DRY 원칙: 서브넷 정보를 한 곳(10-network)에서만 관리
- ✅ 일관성: 서브넷 이름 변경 시 자동 반영
- ✅ 가독성: `subnet_type = "dmz"` 명시적 의미 전달

---

### 2. Jenkinsfile Phase 기반 구조 전환
**목적**: Mock outputs 참조 문제의 근본 원인 해결

#### 문제 분석 (Codex 검증)
**기존 구조**:
```groovy
1. Plan All:   terragrunt run --all -- plan (10-network 미적용 → 50-workloads가 mock 사용)
2. Apply All:  terragrunt run --all -- apply (10-network apply → 50-workloads는 이전 plan 사용 → 404 Error)
```

**에러 로그**:
```
Error: Error getting subnetwork value: googleapi: Error 404:
The resource 'projects/jsj-game-n/regions/asia-northeast3/subnetworks/mock-dmz-subnet' was not found
```

#### 해결 방안 (Phase 기반 순차 실행)
```groovy
def PHASES = [
    [id: 'phase1', label: 'Phase 1 - Bootstrap (00-project)', dirs: ['00-project'], optional: false],
    [id: 'phase2', label: 'Phase 2 - Network (10-network)', dirs: ['10-network'], optional: false],
    [id: 'phase3', label: 'Phase 3 - Storage & Security', dirs: ['20-storage', '30-security'], optional: false],
    [id: 'phase4', label: 'Phase 4 - Observability', dirs: ['40-observability'], optional: true],
    [id: 'phase5', label: 'Phase 5 - Workloads (50-workloads)', dirs: ['50-workloads'], optional: false],
    [id: 'phase6', label: 'Phase 6 - Database & Cache', dirs: ['60-database', '65-cache'], optional: false],
    [id: 'phase7', label: 'Phase 7 - Load Balancers', dirs: ['70-loadbalancers/web', '70-loadbalancers/app', '70-loadbalancers/lobby'], optional: false],
    [id: 'phase8', label: 'Phase 8 - DNS', dirs: ['12-dns'], optional: false]
]
```

**실행 흐름**:
```
Phase 1: 00-project Plan → Approval → Apply → API Propagation (120s)
Phase 2: 10-network Plan → Approval → Apply  (← 실제 subnet 생성)
  ⋮
Phase 5: 50-workloads Plan → Approval → Apply  (← 실제 subnet 참조 가능)
  ⋮
Phase 8: 12-dns Plan → Approval → Apply
```

#### 헬퍼 함수
```groovy
def runPhasePlan(phase, phaseDirs) {
    def includeArgs = phase.dirs.collect {
        "--queue-include-dir '${env.WORKSPACE}/${TG_WORKING_DIR}/${it}'"
    }.join(' ')
    sh "terragrunt run --all ${includeArgs} --working-dir '${env.WORKSPACE}/${TG_WORKING_DIR}' -- plan -out=tfplan-${phase.id}"
}

def runPhaseApply(phase, phaseDirs) {
    def includeArgs = phase.dirs.collect {
        "--queue-include-dir '${env.WORKSPACE}/${TG_WORKING_DIR}/${it}'"
    }.join(' ')
    sh "terragrunt run --all ${includeArgs} --working-dir '${env.WORKSPACE}/${TG_WORKING_DIR}' -- apply tfplan-${phase.id}"
}
```

#### Codex 검증 사항
1. **Terragrunt 0.93+ 구문**: `run --all` + `--queue-include-dir` (✅)
2. **Phase별 Plan 격리**: `tfplan-phase1`, `tfplan-phase2` 등 별도 파일 (✅)
3. **의존성 순서 보장**: Phase 2 apply 완료 → Phase 5 plan 시작 (✅)
4. **Observability skip 로직**: destroy 시에는 항상 포함 (orphan 방지) (✅)

#### 파일 크기
- **Before**: 382줄
- **After**: 347줄 (35줄 감소, 재사용성 향상)

#### 영향
- ✅ Mock outputs 문제 근본 해결
- ✅ 의존성 명확화 (Phase 순서로 표현)
- ✅ Phase별 승인 제어
- ✅ 유지보수성 향상 (Phase 테이블 수정만으로 순서 변경)

---

### 3. 20-storage Bucket Location 자동화
**목적**: GCS bucket location을 region_primary 기반으로 자동 생성

#### 변경 내역
**이전 (하드코딩)**:
```hcl
# terraform.tfvars
assets_bucket_location  = "US-CENTRAL1"
logs_bucket_location    = "US-CENTRAL1"
backups_bucket_location = "US"
```

**변경 후 (terragrunt.hcl에서 자동 주입)**:
```hcl
# terragrunt.hcl
locals {
  # region_primary = "asia-northeast3" → "ASIA-NORTHEAST3"
  region_upper = upper(local.common_inputs.region_primary)

  # region_primary = "asia-northeast3" → "ASIA" (multi-region)
  region_continent = upper(split("-", local.common_inputs.region_primary)[0])
}

inputs = merge(
  local.common_inputs,
  local.layer_inputs_without_auto,
  {
    assets_bucket_location  = local.region_upper       # "ASIA-NORTHEAST3"
    logs_bucket_location    = local.region_upper       # "ASIA-NORTHEAST3"
    backups_bucket_location = local.region_continent   # "ASIA"
  }
)
```

#### Codex 권장사항 적용
- **Same-region 배치**: VM과 bucket을 동일 리전에 배치하여 무료 intra-region 트래픽 및 낮은 latency 확보
- **Multi-region backups**: DR 목적으로 continent 레벨 multi-region 사용 (ASIA/US/EU)
- **Cross-region 회피**: 특별한 이유 없이 다른 리전 사용 금지 (egress 비용 증가)

#### 영향
- ✅ DRY 원칙: region_primary 한 곳에서만 관리
- ✅ 자동 일관성: VM과 bucket이 항상 동일 리전
- ✅ 비용 최적화: Intra-region 트래픽 무료, cross-region egress 회피

---

## 커밋 내역

### 1. `1eeee5d` - refactor(50-workloads): subnet 자동화 구현
- subnet_type 기반 서브넷 선택
- 10-network dependency 설정
- variables.tf validation 추가

### 2. `102eb24` - refactor(jenkinsfile): Phase 기반 순차 배포로 구조 개선
- 8개 Phase 정의 및 순차 실행
- Terragrunt 0.93+ 구문 적용
- Mock outputs 문제 근본 해결

### 3. `8571928` - fix(storage): GCS bucket location을 region_primary와 일치시킴
- assets/logs: ASIA-NORTHEAST3
- backups: ASIA (multi-region)

### 4. `ea8c653` - refactor(storage): Bucket location을 Terragrunt에서 자동 주입하도록 개선
- terragrunt.hcl에서 region_upper, region_continent 자동 변환
- terraform.tfvars에서 *_bucket_location 제거

### 5. `d382bbb` - sync(jenkinsfile): proj-default-templet에 Phase 기반 구조 동기화
- jsj-game-n과 동일한 Phase 기반 구조 적용
- TG_WORKING_DIR만 환경에 맞게 수정

---

## 기술적 결정사항

### Codex MCP와의 협업 패턴 확립
**원칙**: 검증 → 정확한 구현 (사전 검증 우선)

**적용 사례**:
1. **Terragrunt 구문 검증**: Codex가 0.93+ 구문 변경 사항 확인
2. **Module outputs 검증**: `modules/network-dedicated-vpc/outputs.tf` 실제 구조 확인 후 참조
3. **GCS location 전략**: Same-region vs cross-region 아키텍처 검증
4. **Jenkinsfile 구조**: Dynamic stage nesting 가능 여부 확인

**효과**:
- ❌ 이전: 구현 → 에러 → 수정 (3회 반복)
- ✅ 현재: 검증 → 1회 정확한 구현

---

## 다음 단계

### 1. Jenkins 파이프라인 테스트
- [ ] ACTION=plan, TARGET_LAYER=all 실행
- [ ] Phase별 실행 순서 확인
- [ ] 50-workloads가 실제 subnet 참조하는지 검증

### 2. 다른 레이어 자동화 검토
- [ ] 60-database: subnet_type 기반 배치
- [ ] 65-cache: memorystore PSC 자동화
- [ ] 70-loadbalancers: backend_groups 자동 매핑

### 3. Documentation 업데이트
- [ ] README.md에 Phase 기반 배포 플로우 설명
- [ ] 새 프로젝트 생성 가이드 업데이트 (subnet_type 사용법)

---

## 트러블슈팅

### Issue 1: 50-workloads apply 시 mock-dmz-subnet not found (404)
**원인**:
- Jenkinsfile이 모든 레이어를 한 번에 plan
- 10-network 미적용 상태에서 50-workloads plan 생성 → mock 사용
- 이후 apply 시 mock 값 그대로 사용

**해결**:
- Phase 기반 구조로 전환 (Phase 2 apply 완료 후 Phase 5 plan)
- 50-workloads가 항상 실제 subnet outputs 참조

### Issue 2: Terragrunt 명령어 구문 불일치
**원인**:
- 헬퍼 함수에서 deprecated `terragrunt run-all --terragrunt-include-dir` 사용

**해결**:
- Terragrunt 0.93+ 구문으로 수정: `terragrunt run --all --queue-include-dir`

### Issue 3: Observability phase가 destroy 시 skip
**원인**:
- skip 로직이 ACTION 구분 없이 항상 적용

**해결**:
- Destroy 시에는 항상 포함: `&& params.ACTION != 'destroy'`

---

## 참고사항

### Terragrunt Dependency 작동 원리
1. **mock_outputs_allowed_terraform_commands**: init/plan/validate 시에만 mock 사용 허용
2. **Apply 시 동작**: Remote state에서 실제 outputs 읽음 (mock 무시)
3. **문제 상황**: Plan 시 mock으로 생성된 tfplan을 apply 시 그대로 사용하면 mock 값이 적용됨
4. **해결**: Phase별 순차 실행으로 dependency apply 완료 후 dependent plan 생성

### GCS Bucket Location 형식
- **Regional**: `ASIA-NORTHEAST3`, `US-CENTRAL1` (리전명 대문자)
- **Multi-region**: `ASIA`, `US`, `EU` (대륙명 대문자)
- **Dual-region**: `ASIA1` (특정 국가 쌍)

### Jenkinsfile Dynamic Stage
- Declarative Pipeline에서 `script {}` 블록 내 동적 stage 생성 가능
- `orderedPhases.each { stage("${phase.label}") { ... } }` 패턴 사용
- UI에서 sibling stage로 렌더링됨
