# Work History - 2025-11-28

## 작업 개요
70-loadbalancers 레이어의 Instance Group 자동 처리 로직 개선 및 안정화

## 주요 작업 내역

### 1. Jenkins Plan Stage 에러 수정 (Invalid Index)

**문제:**
- 70-loadbalancers/gs의 plan 단계에서 Invalid index 에러 발생
- gcby-gs03이 terraform.tfvars에 정의되어 있지만 아직 VM이 생성되지 않음
- `var.vm_details[inst_name]` 접근 시 에러 발생

**해결:**
```hcl
# 안전한 VM 필터링 로직 추가
resolved_instances = [
  for inst_name in cfg.instances : {
    name      = inst_name
    self_link = var.vm_details[inst_name].self_link
    zone      = var.vm_details[inst_name].zone
  }
  if contains(keys(var.vm_details), inst_name)  # ← 추가
]
```

**파일:** `environments/LIVE/gcp-gcby/70-loadbalancers/gs/main.tf`
**커밋:** 9a2b430

---

### 2. Precondition 에러 수정

**문제:**
- 첫 번째 수정 후 다른 에러 발생
- `resolved_instances`가 빈 배열일 때 precondition에서 에러
- `length(distinct([for inst in each.value.resolved_instances : inst.zone])) == 1` 조건이 빈 배열을 처리하지 못함

**해결:**
두 단계 접근:

1. **2단계 필터링 로직 추가:**
```hcl
# 1단계: 모든 Instance Group 처리
_all_instance_groups = { ... }

# 2단계: 빈 Instance Group 제거
processed_instance_groups = {
  for name, ig in local._all_instance_groups :
  name => ig
  if length(ig.resolved_instances) > 0  # 빈 그룹 제거
}
```

2. **Precondition 개선:**
```hcl
lifecycle {
  precondition {
    # 빈 배열 허용 추가
    condition = length(each.value.resolved_instances) == 0 ||
                length(distinct([...])) == 1
    error_message = "..."
  }
}
```

**파일:** `environments/LIVE/gcp-gcby/70-loadbalancers/gs/main.tf`
**커밋:** 064b812

---

### 3. gcby-gs03 서버 추가

**작업:**
- 50-workloads에 gcby-gs03 정의 추가 (zone_suffix = "c")
- 70-loadbalancers/gs에 gcby-gs-ig-c 정의 추가

**파일:**
- `environments/LIVE/gcp-gcby/50-workloads/terraform.tfvars`
- `environments/LIVE/gcp-gcby/70-loadbalancers/gs/terraform.tfvars`

**커밋:** d434b75

---

### 4. vm_details.auto.tfvars 삭제 (중요!)

**문제 발견:**
- Instance Group import를 위해 임시로 `vm_details.auto.tfvars` 파일을 수동 생성함
- Terragrunt dependency로 자동 주입되어야 하는데 수동 파일이 덮어씀
- VM 추가/삭제 시마다 수동 업데이트 필요 (자동화 의미 없음)

**해결:**
```hcl
# terragrunt.hcl에서 자동 주입
dependency "workloads" {
  config_path = "../../50-workloads"
}

inputs = merge(
  ...
  {
    vm_details = try(dependency.workloads.outputs.vm_details, {})
  }
)
```

**파일:** `environments/LIVE/gcp-gcby/70-loadbalancers/gs/vm_details.auto.tfvars` (삭제)
**커밋:** e2b0dad

---

### 5. Environment 기본값 수정

**작업:**
- variables.tf의 environment 기본값을 "prod"에서 "live"로 변경
- 설명에 "(live, qa-dev)" 추가

**파일:** `environments/LIVE/gcp-gcby/70-loadbalancers/gs/variables.tf`
**커밋:** e2b0dad

---

### 6. proj-default-templet 동기화

**문제:**
- example-http/terragrunt.hcl이 구버전 (45줄)
- dependencies에 50-workloads 누락
- lb_name_defaults 자동 생성 로직 없음

**해결:**
- gcp-gcby/gs/terragrunt.hcl과 동일하게 업데이트 (66줄)
- dependencies에 `../../50-workloads` 추가
- lb_name_defaults 자동 생성 로직 추가
- mock_outputs_allowed_terraform_commands에 "destroy" 추가

**최종 동기화 상태:**
| 파일 | 상태 |
|------|------|
| main.tf | ✅ 완전 동일 (MD5: 3fdc5f7cf61e971dfe305c5374647af8) |
| variables.tf | ✅ 완전 동일 (MD5: 653c362dd57a0ac9e91f8e17645631b7) |
| outputs.tf | ✅ 완전 동일 (MD5: 60a0b98a30a45996cbf7670d7a1d2844) |
| terragrunt.hcl | ✅ 완전 동일 (MD5: 31e9ca94d9ed685b7ca3354106f8b298) |

**파일:** `proj-default-templet/70-loadbalancers/example-http/terragrunt.hcl`
**커밋:** 1bd5e82

---

### 7. VM 자동 삭제 로직 테스트

**테스트:**
- 50-workloads에서 gcby-gs03 삭제
- 70-loadbalancers/gs에서는 gcby-gs-ig-c 정의 유지
- main.tf 로직이 자동으로 Instance Group 삭제하는지 검증

**예상 동작:**
```
1. 50-workloads apply → gcby-gs03 VM 삭제
2. vm_details output에서 gcby-gs03 제거
3. 70-loadbalancers/gs apply 시:
   - vm_details에 gcby-gs03 없음 감지
   - resolved_instances = [] (빈 배열)
   - processed_instance_groups에서 gcby-gs-ig-c 제거
   - Terraform이 gcby-gs-ig-c Instance Group 자동 삭제
```

**검증 완료:** ✅ VM 삭제 시 Instance Group 자동 삭제 확인

**파일:** `environments/LIVE/gcp-gcby/50-workloads/terraform.tfvars`
**커밋:** 758bc5b

---

## 핵심 개선 사항

### 1. 안전한 VM 참조
- VM이 생성되기 전에도 terraform.tfvars에 미리 정의 가능
- `contains(keys(var.vm_details), inst_name)` 필터링으로 안전하게 처리

### 2. 2단계 필터링 로직
```hcl
_all_instance_groups        # 1단계: 모든 IG 처리
  ↓
processed_instance_groups   # 2단계: 빈 IG 제거
  ↓
google_compute_instance_group.lb_instance_group  # 3단계: 리소스 생성
```

### 3. 자동 생성/삭제
- VM 생성 → Instance Group 자동 생성
- VM 삭제 → Instance Group 자동 삭제
- 수동 관리 불필요

### 4. 선택적 로드밸런싱
- terraform.tfvars에 명시한 VM만 LB에 포함
- 모든 VM이 자동으로 LB에 들어가지 않음

---

## 인프라 검증

### 전체 인프라 체크 스크립트 생성
**파일:** `/tmp/check_full_infra.sh`

**검증 항목:**
1. VM 인스턴스 (3개: gs01, gs02, gs03)
2. Instance Groups
3. Backend Services
4. Health Checks
5. URL Maps
6. Target Proxies
7. Forwarding Rules (Load Balancer IP)
8. VPC Networks
9. Subnets
10. Firewall Rules
11. Cloud Routers
12. NAT Gateways
13. Cloud Storage Buckets
14. Cloud SQL Instances
15. Redis Clusters
16. Service Accounts

**주요 발견:**
- ✅ Redis는 Cluster로 생성되어 있음 (gcby-live-redis)
- ✅ Cloud NAT는 존재함 (라우터 이름이 `gcby-live-vpc-cr`로 확인됨)
- ❌ Secret Manager API는 비활성화 상태 (observability에서 slack notification 비활성화되어 있어 필요 없음)

---

## 관련 문서 업데이트

### 70-loadbalancers README
**업데이트 필요:**
- 2단계 필터링 로직 설명
- VM 자동 생성/삭제 동작 설명
- vm_details dependency 설명

### Troubleshooting 가이드
**추가 필요:**
- Invalid index 에러 해결 방법
- Precondition 에러 해결 방법
- vm_details.auto.tfvars를 만들지 말 것

---

## Git Commits

```
1bd5e82 fix(proj-default-templet): example-http terragrunt.hcl 동기화
758bc5b test: gcby-gs03 서버 삭제 테스트 (자동 삭제 로직 검증)
e2b0dad fix(70-loadbalancers): vm_details.auto.tfvars 삭제 및 environment 기본값 수정
064b812 fix(70-loadbalancers): 빈 Instance Group 처리 로직 개선
d434b75 feat(gcp-gcby): gcby-gs03 서버 및 Instance Group 추가
9a2b430 fix(70-loadbalancers): VM이 아직 생성되지 않은 경우 안전하게 처리
```

---

### 8. Backend Service 삭제 순서 문제 발견 및 해결

**문제:**
- Instance Group 삭제 시 `resourceInUseByAnotherResource` 에러 발생
- Backend Service가 여전히 Instance Group을 사용 중
- Terraform이 삭제 순서를 잘못 계산함
  - 올바른 순서: Backend Service 업데이트 → Instance Group 삭제
  - 실제 순서: Instance Group 삭제 시도 → 에러

**에러 메시지:**
```
Error: Error deleting InstanceGroup: googleapi: Error 400: The instance_group resource
'projects/gcp-gcby/zones/us-west1-c/instanceGroups/gcby-gs-ig-c' is already being used by
'projects/gcp-gcby/global/backendServices/gcby-gs-backend', resourceInUseByAnotherResource
```

**근본 원인:**
- Terraform Core의 설계 제약 (GitHub Issue #6376)
- `local.auto_backends`가 동적으로 생성되어 dependency 추적 불가
- Provider가 리소스 삭제 순서를 제어할 수 없음

**시도한 해결책 #1: destroy provisioner (실패)**
```hcl
resource "google_compute_instance_group" "lb_instance_group" {
  # Instance Group 삭제 전에 Backend Service에서 제거
  provisioner "local-exec" {
    when    = destroy
    command = <<-EOT
      # Backend에서 자동 제거 로직
    EOT
  }
}
```

**실패 원인:**
- `for_each`에서 key 제거 시 provisioner가 실행되지 않음
- 로그에 provisioner 실행 흔적 없음

**최종 해결책: cleanup_backends.sh 스크립트**

스크립트 동작:
1. terraform.tfvars에서 정의된 instance_groups 파싱
2. Backend Service의 현재 backends 확인
3. Backend에는 있지만 tfvars에 없는 Instance Group 찾기
4. gcloud로 Backend Service에서 자동 제거

**파일:** `environments/LIVE/gcp-gcby/70-loadbalancers/gs/cleanup_backends.sh`
**커밋:** f8f16df

---

### 9. Jenkins 파이프라인 자동화

**구현:**
- Phase 7 apply 전에 cleanup_backends.sh 자동 실행
- Execute All Phases (all 실행)와 Single Layer (개별 실행) 모두 지원
- cleanup 스크립트 존재 여부 자동 확인

**Jenkins 동작 흐름:**
```
Phase 7 Apply 시작
  ↓
1. cleanup_backends.sh 자동 실행
   - terraform.tfvars 파싱
   - Backend Service와 비교
   - 제거할 Instance Group detach
  ↓
2. terragrunt plan (최신 상태 기준)
  ↓
3. terragrunt apply
   - ✅ 에러 없이 Instance Group 삭제 완료
```

**파일:** `environments/LIVE/gcp-gcby/Jenkinsfile`
**커밋:** 375b9dc

---

### 10. proj-default-templet 템플릿 추가

**작업:**
- cleanup_backends.sh를 모든 70-loadbalancers 폴더에 추가
  - example-http/cleanup_backends.sh
  - app/cleanup_backends.sh
  - lobby/cleanup_backends.sh
  - web/cleanup_backends.sh
- destroy provisioner 제거 (gcp-gcby/gs + proj-default-templet 4개)

**파일:**
- `proj-default-templet/70-loadbalancers/*/cleanup_backends.sh` (4개)
- `proj-default-templet/70-loadbalancers/*/main.tf` (4개)

**커밋:** bae2877

---

## 베스트 프랙티스 조사

### 인터넷 검색 결과

**GitHub Issue #6376:**
- "Cannot delete instance group because it's being used by a backend service"
- Terraform Core의 근본적인 제약으로 해결 불가능
- "It's not a simple task to fix this"

**공식 Google 모듈 접근:**
- `dynamic_backends` 서브모듈 사용
- `lifecycle { ignore_changes = [backend] }` 적용
- 외부 시스템(GKE, AutoNEG)이 backend를 관리하도록 함
- Terraform은 초기 생성만 하고 이후 변경은 무시

**우리 상황과의 차이:**
- 우리는 Terraform이 `local.auto_backends`로 backend를 **동적으로 관리**
- `ignore_changes`를 쓰면 Terraform이 backend를 전혀 관리하지 않게 됨
- 다른 workaround들은 우리 use case에 맞지 않음

**결론:**
- cleanup 스크립트가 가장 현실적이고 베스트 프랙티스에 가까운 해결책
- Jenkins 파이프라인에 통합하여 완전 자동화
- 수동 개입 불필요

---

## 교훈

### ✅ 좋았던 점
1. 2단계 필터링으로 깔끔하게 문제 해결
2. Terragrunt dependency 활용한 자동화
3. 선택적 로드밸런싱 구조 유지
4. proj-default-templet 동기화 완료
5. 베스트 프랙티스 조사를 통한 근본 원인 파악
6. Jenkins 파이프라인 완전 자동화 (수동 개입 불필요)
7. cleanup 스크립트로 Terraform 제약 우회

### ⚠️ 개선할 점
1. vm_details.auto.tfvars를 처음부터 만들지 말았어야 함
2. 자동화된 시스템에 수동 파일 추가는 안티패턴
3. 코드 검증 시 정밀하게 확인 필요 (Redis Cluster vs Instance, Cloud NAT 라우터 이름 등)
4. destroy provisioner 시도 전에 for_each 제약 확인 필요
5. 근본 원인부터 해결 (임시 해결보다 근본 해결 우선)

---

## Git Commits (최종)

```
bae2877 feat(proj-default-templet): cleanup_backends.sh 템플릿 추가
375b9dc feat(jenkins): Phase 7 apply 전에 cleanup_backends.sh 자동 실행
f8f16df feat(70-loadbalancers/gs): Backend cleanup 스크립트 추가 및 gcby-gs-ig-c 제거
3ca2472 test(50-workloads): gcby-gs03 인스턴스 제거
db90c08 test(50-workloads): gcby-gs03 인스턴스 추가
cece5db test(70-loadbalancers/gs): gcby-gs-ig-c Instance Group 추가
6c6ef42 fix(70-loadbalancers): Instance Group에 자동 backend 제거 provisioner 추가
1bd5e82 fix(proj-default-templet): example-http terragrunt.hcl 동기화
758bc5b test: gcby-gs03 서버 삭제 테스트 (자동 삭제 로직 검증)
e2b0dad fix(70-loadbalancers): vm_details.auto.tfvars 삭제 및 environment 기본값 수정
064b812 fix(70-loadbalancers): 빈 Instance Group 처리 로직 개선
d434b75 feat(gcp-gcby): gcby-gs03 서버 및 Instance Group 추가
9a2b430 fix(70-loadbalancers): VM이 아직 생성되지 않은 경우 안전하게 처리
```

---

## 다음 작업 예정

1. ✅ 70-loadbalancers README 업데이트
2. ✅ Troubleshooting 가이드 추가
3. 다른 로드밸런서 추가 (app, lobby, web)
4. gcby-gs03 복원 (삭제 테스트 완료 후)
