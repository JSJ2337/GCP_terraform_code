# 2025-12-03 작업 이력

## 작업 개요

### 주요 작업
1. PSC Forwarding Rule Apply 검증 및 Cross-Region 연결 테스트
2. Multi-Region/Multi-Project PSC 스케일링 전략 수립
3. Cloud SQL Database/User 자동 네이밍 구현
4. Password Lifecycle 관리 (ignore_changes) 구현
5. Terraform Best Practice 리서치 및 적용
6. DBeaver 연결 검증 완료

---

## 1. PSC Forwarding Rule Apply 검증

### 확인 사항
```bash
# PSC Forwarding Rule 상태 확인
gcloud compute forwarding-rules describe psc-fr-gcby-cloudsql \
  --region=us-west1 --project=gcp-mgmt-us

# 결과
allowPscGlobalAccess: true
pscConnectionStatus: ACCEPTED
IPAddress: 10.250.20.20
```

### Cross-Region 연결 테스트
- **Bastion 위치**: asia-northeast3
- **Cloud SQL 위치**: us-west1
- **결과**: ✅ Global Access로 정상 연결
- **검증**: MySQL handshake 수신 확인

### 학습 포인트
PSC Global Access 설정으로 단일 Forwarding Rule이 모든 리전에서 사용 가능함을 확인

---

## 2. Multi-Region/Multi-Project PSC 스케일링 전략

### 질문 및 답변

**Q1: 리전이 늘어날 때마다 PSC Forwarding Rule이 늘어나나?**

**A1: 상황에 따라 다름**
- **새 리전에 Cloud SQL 추가** → 새 PSC FR 필요 (다른 Service Attachment)
- **새 리전에 VM만 추가** → 기존 PSC FR 재사용 (Global Access)
- **같은 리전에 Cloud SQL 추가** → 새 PSC FR 필요 (IP는 다름, 같은 subnet)

**Q2: 새 프로젝트마다 IP만 따로 해주면 되는가?**

**A2: 맞습니다**
- 프로젝트당 고유 IP 할당 (같은 subnet 내)
- PSC subnet 공유 가능 (/24에서 여러 IP 할당)
- 예시:
  - gcby: 10.250.20.20
  - game2: 10.250.20.21
  - game3: 10.250.20.22

### 스케일링 패턴 정리

| 시나리오 | 필요한 리소스 |
|---------|--------------|
| 같은 리전, 새 Cloud SQL | 새 PSC FR (같은 subnet, 다른 IP) |
| 다른 리전, 새 Cloud SQL | 새 Subnet + 새 PSC FR |
| 다른 리전, VM만 추가 | 없음 (Global Access 활용) |

---

## 3. Cloud SQL Database/User 자동 네이밍 구현

### 문제점
- 매 프로젝트마다 database/user 이름을 수동 설정
- DRY 원칙 위배
- 실수 가능성

### 해결 방법: Terraform Locals 사용

#### 리서치 결과
- ✅ Terraform tfvars에서는 변수 참조 불가
- ✅ Locals에서 동적 생성 가능
- ✅ 업계 표준 패턴 확인

#### 구현 코드

**environments/LIVE/gcp-gcby/60-database/main.tf**
```hcl
locals {
  # Database 자동 생성 (프로젝트명 기반)
  databases_auto = [
    {
      name      = "${var.project_name}_gamedb"
      charset   = "utf8mb4"
      collation = "utf8mb4_unicode_ci"
    }
  ]

  # Users 자동 생성 (프로젝트명 기반)
  users_auto = [
    {
      name     = "root"
      password = var.db_root_password
      host     = "%"
    },
    {
      name     = "${var.project_name}_app_user"
      password = var.db_app_password
      host     = "%"
    }
  ]

  # 최종: 자동 생성 + 수동 추가
  databases_final = concat(local.databases_auto, var.databases)
  users_final = concat(local.users_auto, var.users)
}

module "mysql" {
  source = "../../../../modules/cloudsql-mysql"
  # ...
  databases = local.databases_final
  users = local.users_final
}
```

**environments/LIVE/gcp-gcby/60-database/variables.tf**
```hcl
variable "db_root_password" {
  type        = string
  description = "Root 사용자 비밀번호 (TODO: Secret Manager로 관리)"
  sensitive   = true
  default     = "TempPassword123!ChangeMeLater"
}

variable "db_app_password" {
  type        = string
  description = "Application 사용자 비밀번호 (TODO: Secret Manager로 관리)"
  sensitive   = true
  default     = "AppPassword456!ChangeMeLater"
}
```

**environments/LIVE/gcp-gcby/60-database/terraform.tfvars**
```hcl
# Databases to create
# 자동 생성: {project_name}_gamedb (main.tf의 locals에서 생성)
# 추가 database가 필요한 경우에만 여기에 명시
databases = []

# Users to create
# 자동 생성: root, {project_name}_app_user (main.tf의 locals에서 생성)
# 추가 user가 필요한 경우에만 여기에 명시
users = []
```

### 결과
- ✅ 프로젝트 gcby → `gcby_gamedb`, `gcby_app_user` 자동 생성
- ✅ 프로젝트 game2 → `game2_gamedb`, `game2_app_user` 자동 생성
- ✅ 추가 database/user는 tfvars 배열에 추가 가능

---

## 4. Password Lifecycle 관리

### 문제점
**Q: 사용자가 GCP Console에서 패스워드를 변경하면?**
- Terraform apply 시 초기 패스워드로 되돌림 (원치 않는 동작)

### 해결: lifecycle ignore_changes

**modules/cloudsql-mysql/main.tf**
```hcl
resource "google_sql_user" "users" {
  for_each = { for user in var.users : user.name => user }

  name     = each.value.name
  instance = google_sql_database_instance.instance.name
  password = each.value.password
  host     = lookup(each.value, "host", "%")
  project  = var.project_id

  # 비밀번호 변경 시 Terraform이 되돌리지 않도록 설정
  lifecycle {
    ignore_changes = [password]
  }
}
```

### 동작 방식
1. **초기 생성**: Terraform이 `db_root_password`로 user 생성
2. **사용자 수동 변경**: GCP Console/gcloud로 패스워드 변경 가능
3. **Terraform Apply**: 패스워드 변경 무시 (되돌리지 않음)

### 패스워드 분실 시 대응 방법

#### 방법 1: gcloud 명령으로 재설정 (권장)
```bash
gcloud sql users set-password root \
  --instance=gcby-live-gdb-m1 \
  --password="NewPassword!" \
  --project=gcp-gcby
```

#### 방법 2: Terraform 리소스 재생성
```bash
# 1. State에서 제거
terraform state rm 'module.mysql.google_sql_user.users["root"]'

# 2. GCP에서 삭제
gcloud sql users delete root --instance=gcby-live-gdb-m1 --project=gcp-gcby

# 3. variables.tf에서 새 패스워드 설정 후 재생성
terraform apply -target='module.mysql.google_sql_user.users["root"]'
```

---

## 5. Terraform Best Practice 리서치

### 조사 내용: password vs password_wo

#### 현재 방식: `password` + `ignore_changes`
- ✅ 업계 표준 패턴 (AWS RDS, Azure SQL, GCP Cloud SQL 공통)
- ✅ 직관적이고 이해하기 쉬움
- ⚠️ State 파일에 패스워드 저장 (보안 이슈)

#### 최신 방식: `password_wo` (Write-Only)
```hcl
resource "google_sql_user" "user" {
  name     = "myuser"
  instance = google_sql_database_instance.main.name

  password_wo         = var.db_password
  password_wo_version = 1  # 변경 시에만 증가
}
```

**장점:**
- State 파일에 패스워드 미저장 (보안 향상)
- Warning 메시지 없음

**단점:**
- 비교적 새로운 기능 (레퍼런스 부족)
- 패스워드 변경 시 version도 증가시켜야 함

### 결정: 현재 방식 유지
- 검증된 패턴
- 운영 팀이 이해하기 쉬움
- Secret Manager 마이그레이션 전까지는 현행 유지

---

## 6. DBeaver 연결 검증

### 초기 에러
```
Communications link failure
The driver has not received any packets from the server
```

**원인**: PSC는 Private DNS만 지원, 로컬 PC에서 직접 접근 불가

### 해결
- ✅ DBeaver SSH 터널 설정 (Bastion Host 경유)
- ✅ 접속 주소: `gcby-live-gdb-m1.delabsgames.internal`
- ✅ 연결 성공 확인

### 생성된 리소스 확인
```bash
# Database
gcloud sql databases list --instance=gcby-live-gdb-m1 --project=gcp-gcby
# 결과: gcby_gamedb ✅

# Users
gcloud sql users list --instance=gcby-live-gdb-m1 --project=gcp-gcby
# 결과: root, gcby_app_user ✅
```

---

## 커밋 이력

### Commit: bc49084
**메시지**: 초기 users/databases 추가 (이후 리팩토링)
**변경사항**:
- terraform.tfvars에 database/user 수동 추가 (후에 locals로 대체됨)

### Commit: 314197e
**메시지**: Dynamic database/user naming using locals and project_name
**변경사항**:
- `environments/LIVE/gcp-gcby/60-database/main.tf`: locals 추가 (databases_auto, users_auto)
- `environments/LIVE/gcp-gcby/60-database/variables.tf`: db_root_password, db_app_password 추가
- `environments/LIVE/gcp-gcby/60-database/terraform.tfvars`: databases/users 빈 배열로 변경
- `proj-default-templet/60-database/*`: 모든 변경사항 템플릿 동기화

### Commit: 381bda8
**메시지**: Lifecycle ignore_changes for password management
**변경사항**:
- `modules/cloudsql-mysql/main.tf`: google_sql_user에 lifecycle 블록 추가
- `proj-default-templet/60-database/*`: 템플릿 동기화

### Commit: 0d6c42f
**메시지**: 테스트
**변경사항**:
- 최종 테스트 및 검증

---

## 영향을 받은 파일

### 모듈 파일
- `modules/cloudsql-mysql/main.tf`
  - google_sql_user에 lifecycle ignore_changes 추가

### 환경 파일
- `environments/LIVE/gcp-gcby/60-database/main.tf`
  - locals에 databases_auto, users_auto, databases_final, users_final 추가
- `environments/LIVE/gcp-gcby/60-database/variables.tf`
  - db_root_password, db_app_password 변수 추가
- `environments/LIVE/gcp-gcby/60-database/terraform.tfvars`
  - databases, users 빈 배열로 변경 (주석 추가)

### 템플릿 파일
- `proj-default-templet/60-database/main.tf`
- `proj-default-templet/60-database/variables.tf`
- `proj-default-templet/60-database/terraform.tfvars`

---

## 학습 및 개선 사항

### Terraform Best Practices
1. **Locals vs Variables**
   - tfvars에서는 변수 참조 불가
   - 동적 생성은 main.tf의 locals 사용

2. **Password 관리**
   - `lifecycle { ignore_changes }` 패턴은 업계 표준
   - Write-Only 속성은 최신 기능이지만 현행 유지

3. **DRY 원칙**
   - 프로젝트명 한 곳에서 정의, 여러 곳에서 재사용
   - 자동 생성 + 수동 추가 조합 패턴

### PSC 아키텍처 이해
1. **Global Access의 의미**
   - 단일 PSC FR이 모든 리전 서빙 가능
   - Cross-Region 연결 지원

2. **스케일링 전략**
   - 리전별 Cloud SQL → 리전별 PSC FR
   - 프로젝트별 Cloud SQL → IP만 추가 할당

---

## 다음 단계

### 즉시 수행
- ✅ Jenkins apply로 database/user 생성 완료
- ✅ DBeaver 연결 검증 완료

### 향후 계획
1. **Secret Manager 통합** (우선순위: 중)
   - 패스워드를 Secret Manager로 마이그레이션
   - State 파일에서 패스워드 제거

2. **password_wo 마이그레이션** (우선순위: 하)
   - 최신 Write-Only 속성 적용 검토

3. **IAM Database Authentication** (우선순위: 하)
   - 패스워드 기반 → IAM 기반 인증 전환 검토

---

---

## 7. 네트워크 설정 중앙화 및 하드코딩 제거

### 문제 인식
- IP 주소, CIDR, VPC Peering 정보가 여러 파일에 하드코딩됨
- 새 프로젝트 추가 시 여러 파일을 수정해야 함
- 설정 불일치 위험

### 구현 내용

#### 7.1 common.naming.tfvars 중앙 집중화

**environments/LIVE/gcp-gcby/common.naming.tfvars**
```hcl
network_config = {
  # Subnet CIDR
  subnets = {
    dmz     = "10.10.10.0/24"
    private = "10.10.11.0/24"
    psc     = "10.10.12.0/24"
  }

  # PSC Endpoint IP
  psc_endpoints = {
    cloudsql = "10.10.12.51"
    redis    = "10.10.12.101"
  }

  # VPC Peering
  peering = {
    mgmt_project_id = "delabs-gcp-mgmt"
    mgmt_vpc_name   = "delabs-gcp-mgmt-vpc"
  }

  # VM Static IP
  vm_ips = {
    gs01 = "10.10.11.3"
    gs02 = "10.10.11.6"
  }
}
```

#### 7.2 VPC Peering 변수화
- `gcp-gcby/10-network/main.tf`: peer_network를 변수로 전달받음
- `gcp-gcby/10-network/terragrunt.hcl`: network_config에서 peer_network_url 동적 생성

#### 7.3 DNS 레코드 IP 동적 생성
- `gcp-gcby/12-dns/terragrunt.hcl`: network_config에서 IP 추출하여 DNS 레코드 자동 생성
- `bootstrap/12-dns/layer.hcl`: common.hcl에서 IP 참조

#### 7.4 Subnet CIDR 동적 생성
- `gcp-gcby/10-network/terragrunt.hcl`: network_config.subnets에서 CIDR 자동 추출
- terraform.tfvars의 additional_subnets 하드코딩 제거

### 커밋 이력

**Commit: 2a2bfe8**
```
refactor: 네트워크 설정 중앙화 및 하드코딩 제거

- common.naming.tfvars에 network_config 추가
- VPC Peering 변수화
- DNS 레코드 IP 변수화
- Subnet CIDR 동적 생성
```

**수정 파일**: 11개 (+155줄, -31줄)

---

## 8. Bootstrap 일반화 - 다중 프로젝트 지원

### 문제점
- bootstrap이 gcby 프로젝트에 특화되어 있음
- 새 프로젝트 추가 시 여러 곳을 수정해야 함
- VPC Peering, PSC Endpoint, DNS 레코드가 하드코딩됨

### 해결 방법: projects 구조 도입

#### 8.1 bootstrap/common.hcl - projects 맵 구조

```hcl
locals {
  projects = {
    gcby = {
      project_id   = "gcp-gcby"
      environment  = "live"
      vpc_name     = "gcby-live-vpc"
      network_url  = "projects/gcp-gcby/global/networks/gcby-live-vpc"

      psc_ips = {
        cloudsql = "10.250.20.20"
        redis    = "10.250.20.101"
      }

      vm_ips = {
        gs01 = "10.10.11.3"
        gs02 = "10.10.11.6"
      }

      database_path = "../../environments/LIVE/gcp-gcby/60-database"
      cache_path    = "../../environments/LIVE/gcp-gcby/65-cache"
    }
    # 새 프로젝트는 여기에 추가
  }
}
```

#### 8.2 bootstrap/10-network - 동적 리소스 생성

**terragrunt.hcl 변경:**
- Dependency 경로를 projects에서 참조
- PSC Endpoints를 projects 구조에서 동적 생성
- VPC Peering 대상을 projects에서 추출

**main.tf 변경:**
- VPC Peering을 for_each로 동적 생성
- PSC Endpoints를 terragrunt에서 전달받음

**variables.tf 변경:**
- gcby 전용 변수 제거
- project_vpc_network_urls 추가 (map)

#### 8.3 bootstrap/12-dns - DNS 레코드 동적 생성

```hcl
locals {
  # mgmt VM (고정)
  mgmt_vm_records = { ... }

  # 프로젝트 VM (동적)
  project_vm_records = merge([
    for project_key, project in local.projects : {
      for vm_name, vm_ip in project.vm_ips :
      "${project_key}-${vm_name}" => { ... }
    }
  ]...)

  # PSC Endpoints (동적)
  project_psc_records = merge([
    for project_key, project in local.projects : {
      "${project_key}-${project.environment}-gdb-m1" => { ... }
      "${project_key}-${project.environment}-redis" => { ... }
    }
  ]...)
}
```

### 새 프로젝트 추가 방법 (예: abc)

#### 1단계: bootstrap/common.hcl
```hcl
projects = {
  gcby = { ... }
  abc = {
    project_id  = "gcp-abc"
    vpc_name    = "abc-live-vpc"
    psc_ips     = { cloudsql = "10.250.21.20", redis = "10.250.21.101" }
    vm_ips      = { web01 = "10.20.11.10" }
    database_path = "../../environments/LIVE/gcp-abc/60-database"
    cache_path    = "../../environments/LIVE/gcp-abc/65-cache"
  }
}
```

#### 2단계: bootstrap/10-network/terragrunt.hcl (3곳 수정)
```hcl
# A) Dependency 블록 추가
dependency "abc_database" { ... }
dependency "abc_cache" { ... }

# B) PSC Endpoints 로컬 변수 추가
locals {
  psc_endpoints_abc = { ... }

  # C) Merge 구문에 추가
  all_psc_endpoints = merge(
    local.psc_endpoints_gcby,
    local.psc_endpoints_abc,
  )
}
```

#### 3단계: 자동 반영
- ✅ VPC Peering: 자동 생성
- ✅ DNS 레코드: 자동 생성

### 커밋 이력

**Commit: 99eb970**
```
refactor: bootstrap 일반화 - 다중 프로젝트 지원

- bootstrap/common.hcl에 projects 구조 도입
- bootstrap/10-network 동적 리소스 생성 (VPC Peering, PSC)
- bootstrap/12-dns DNS 레코드 동적 생성
```

**수정 파일**: 5개 (+209줄, -114줄)

---

## 참고 자료

### Terraform Documentation
- [google_sql_user Resource](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/sql_user)
- [Terraform Lifecycle Meta-Arguments](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle)
- [How to Use Ignore_Changes in Terraform Lifecycle](https://spacelift.io/blog/terraform-ignore-changes)
- [Terraform for_each Meta-Argument](https://developer.hashicorp.com/terraform/language/meta-arguments/for_each)
- [Terraform Dynamic Blocks](https://developer.hashicorp.com/terraform/language/expressions/dynamic-blocks)

### Stack Overflow References
- [Creating Cloud SQL User with Terraform](https://stackoverflow.com/questions/52688448/creating-a-google-sql-user-with-terraform-always-recreates-the-resource)
- [Terraform Azure SQL Password Management](https://stackoverflow.com/questions/65143585/terraform-azure-sql-server-admin-password-change-forces-recreating-of-resource)

### GCP Documentation
- [Manage users with built-in authentication](https://cloud.google.com/sql/docs/mysql/create-manage-users)
- [gcloud sql users set-password](https://cloud.google.com/sdk/gcloud/reference/sql/users/set-password)
- [Private Service Connect](https://cloud.google.com/vpc/docs/private-service-connect)

---

## 요약

### 완료된 작업
- ✅ PSC Global Access 검증 및 Cross-Region 연결 테스트
- ✅ Multi-Region/Multi-Project PSC 스케일링 전략 수립
- ✅ Cloud SQL Database/User 자동 네이밍 구현
- ✅ Password Lifecycle 관리 (ignore_changes) 구현
- ✅ Terraform Best Practice 리서치 및 검증
- ✅ DBeaver SSH 터널 연결 성공
- ✅ 네트워크 설정 중앙화 (common.naming.tfvars)
- ✅ Bootstrap 일반화 - 다중 프로젝트 지원 구조

### 생성된 리소스
- `gcby_gamedb` (Database)
- `root` (User)
- `gcby_app_user` (User)

### 핵심 성과
1. **자동화 향상**: 프로젝트명 기반 자동 리소스 생성
2. **운영 편의성**: 패스워드 수동 변경 허용 (Terraform이 되돌리지 않음)
3. **확장성**: 모든 신규 프로젝트에 자동 적용 (템플릿 동기화 완료)
4. **검증된 패턴**: 업계 표준 best practice 적용
5. **중앙 집중화**: 네트워크 설정을 단일 진실 소스에서 관리
6. **재사용성**: Bootstrap이 다중 프로젝트 지원 (새 프로젝트 추가 3단계)
