# 2025-12-03 작업 이력

## 작업 개요

### 주요 작업
1. PSC Forwarding Rule Apply 검증 및 Cross-Region 연결 테스트
2. Multi-Region/Multi-Project PSC 스케일링 전략 수립
3. Cloud SQL Database/User 자동 네이밍 구현
4. Password Lifecycle 관리 (ignore_changes) 구현
5. Terraform Best Practice 리서치 및 적용
6. DBeaver 연결 검증 완료

---

## 1. PSC Forwarding Rule Apply 검증

### 확인 사항
```bash
# PSC Forwarding Rule 상태 확인
gcloud compute forwarding-rules describe psc-fr-gcby-cloudsql \
  --region=us-west1 --project=gcp-mgmt-us

# 결과
allowPscGlobalAccess: true
pscConnectionStatus: ACCEPTED
IPAddress: 10.250.20.20
```

### Cross-Region 연결 테스트
- **Bastion 위치**: asia-northeast3
- **Cloud SQL 위치**: us-west1
- **결과**: ✅ Global Access로 정상 연결
- **검증**: MySQL handshake 수신 확인

### 학습 포인트
PSC Global Access 설정으로 단일 Forwarding Rule이 모든 리전에서 사용 가능함을 확인

---

## 2. Multi-Region/Multi-Project PSC 스케일링 전략

### 질문 및 답변

**Q1: 리전이 늘어날 때마다 PSC Forwarding Rule이 늘어나나?**

**A1: 상황에 따라 다름**
- **새 리전에 Cloud SQL 추가** → 새 PSC FR 필요 (다른 Service Attachment)
- **새 리전에 VM만 추가** → 기존 PSC FR 재사용 (Global Access)
- **같은 리전에 Cloud SQL 추가** → 새 PSC FR 필요 (IP는 다름, 같은 subnet)

**Q2: 새 프로젝트마다 IP만 따로 해주면 되는가?**

**A2: 맞습니다**
- 프로젝트당 고유 IP 할당 (같은 subnet 내)
- PSC subnet 공유 가능 (/24에서 여러 IP 할당)
- 예시:
  - gcby: 10.250.20.20
  - game2: 10.250.20.21
  - game3: 10.250.20.22

### 스케일링 패턴 정리

| 시나리오 | 필요한 리소스 |
|---------|--------------|
| 같은 리전, 새 Cloud SQL | 새 PSC FR (같은 subnet, 다른 IP) |
| 다른 리전, 새 Cloud SQL | 새 Subnet + 새 PSC FR |
| 다른 리전, VM만 추가 | 없음 (Global Access 활용) |

---

## 3. Cloud SQL Database/User 자동 네이밍 구현

### 문제점
- 매 프로젝트마다 database/user 이름을 수동 설정
- DRY 원칙 위배
- 실수 가능성

### 해결 방법: Terraform Locals 사용

#### 리서치 결과
- ✅ Terraform tfvars에서는 변수 참조 불가
- ✅ Locals에서 동적 생성 가능
- ✅ 업계 표준 패턴 확인

#### 구현 코드

**environments/LIVE/gcp-gcby/60-database/main.tf**
```hcl
locals {
  # Database 자동 생성 (프로젝트명 기반)
  databases_auto = [
    {
      name      = "${var.project_name}_gamedb"
      charset   = "utf8mb4"
      collation = "utf8mb4_unicode_ci"
    }
  ]

  # Users 자동 생성 (프로젝트명 기반)
  users_auto = [
    {
      name     = "root"
      password = var.db_root_password
      host     = "%"
    },
    {
      name     = "${var.project_name}_app_user"
      password = var.db_app_password
      host     = "%"
    }
  ]

  # 최종: 자동 생성 + 수동 추가
  databases_final = concat(local.databases_auto, var.databases)
  users_final = concat(local.users_auto, var.users)
}

module "mysql" {
  source = "../../../../modules/cloudsql-mysql"
  # ...
  databases = local.databases_final
  users = local.users_final
}
```

**environments/LIVE/gcp-gcby/60-database/variables.tf**
```hcl
variable "db_root_password" {
  type        = string
  description = "Root 사용자 비밀번호 (TODO: Secret Manager로 관리)"
  sensitive   = true
  default     = "TempPassword123!ChangeMeLater"
}

variable "db_app_password" {
  type        = string
  description = "Application 사용자 비밀번호 (TODO: Secret Manager로 관리)"
  sensitive   = true
  default     = "AppPassword456!ChangeMeLater"
}
```

**environments/LIVE/gcp-gcby/60-database/terraform.tfvars**
```hcl
# Databases to create
# 자동 생성: {project_name}_gamedb (main.tf의 locals에서 생성)
# 추가 database가 필요한 경우에만 여기에 명시
databases = []

# Users to create
# 자동 생성: root, {project_name}_app_user (main.tf의 locals에서 생성)
# 추가 user가 필요한 경우에만 여기에 명시
users = []
```

### 결과
- ✅ 프로젝트 gcby → `gcby_gamedb`, `gcby_app_user` 자동 생성
- ✅ 프로젝트 game2 → `game2_gamedb`, `game2_app_user` 자동 생성
- ✅ 추가 database/user는 tfvars 배열에 추가 가능

---

## 4. Password Lifecycle 관리

### 문제점
**Q: 사용자가 GCP Console에서 패스워드를 변경하면?**
- Terraform apply 시 초기 패스워드로 되돌림 (원치 않는 동작)

### 해결: lifecycle ignore_changes

**modules/cloudsql-mysql/main.tf**
```hcl
resource "google_sql_user" "users" {
  for_each = { for user in var.users : user.name => user }

  name     = each.value.name
  instance = google_sql_database_instance.instance.name
  password = each.value.password
  host     = lookup(each.value, "host", "%")
  project  = var.project_id

  # 비밀번호 변경 시 Terraform이 되돌리지 않도록 설정
  lifecycle {
    ignore_changes = [password]
  }
}
```

### 동작 방식
1. **초기 생성**: Terraform이 `db_root_password`로 user 생성
2. **사용자 수동 변경**: GCP Console/gcloud로 패스워드 변경 가능
3. **Terraform Apply**: 패스워드 변경 무시 (되돌리지 않음)

### 패스워드 분실 시 대응 방법

#### 방법 1: gcloud 명령으로 재설정 (권장)
```bash
gcloud sql users set-password root \
  --instance=gcby-live-gdb-m1 \
  --password="NewPassword!" \
  --project=gcp-gcby
```

#### 방법 2: Terraform 리소스 재생성
```bash
# 1. State에서 제거
terraform state rm 'module.mysql.google_sql_user.users["root"]'

# 2. GCP에서 삭제
gcloud sql users delete root --instance=gcby-live-gdb-m1 --project=gcp-gcby

# 3. variables.tf에서 새 패스워드 설정 후 재생성
terraform apply -target='module.mysql.google_sql_user.users["root"]'
```

---

## 5. Terraform Best Practice 리서치

### 조사 내용: password vs password_wo

#### 현재 방식: `password` + `ignore_changes`
- ✅ 업계 표준 패턴 (AWS RDS, Azure SQL, GCP Cloud SQL 공통)
- ✅ 직관적이고 이해하기 쉬움
- ⚠️ State 파일에 패스워드 저장 (보안 이슈)

#### 최신 방식: `password_wo` (Write-Only)
```hcl
resource "google_sql_user" "user" {
  name     = "myuser"
  instance = google_sql_database_instance.main.name

  password_wo         = var.db_password
  password_wo_version = 1  # 변경 시에만 증가
}
```

**장점:**
- State 파일에 패스워드 미저장 (보안 향상)
- Warning 메시지 없음

**단점:**
- 비교적 새로운 기능 (레퍼런스 부족)
- 패스워드 변경 시 version도 증가시켜야 함

### 결정: 현재 방식 유지
- 검증된 패턴
- 운영 팀이 이해하기 쉬움
- Secret Manager 마이그레이션 전까지는 현행 유지

---

## 6. DBeaver 연결 검증

### 초기 에러
```
Communications link failure
The driver has not received any packets from the server
```

**원인**: PSC는 Private DNS만 지원, 로컬 PC에서 직접 접근 불가

### 해결
- ✅ DBeaver SSH 터널 설정 (Bastion Host 경유)
- ✅ 접속 주소: `gcby-live-gdb-m1.delabsgames.internal`
- ✅ 연결 성공 확인

### 생성된 리소스 확인
```bash
# Database
gcloud sql databases list --instance=gcby-live-gdb-m1 --project=gcp-gcby
# 결과: gcby_gamedb ✅

# Users
gcloud sql users list --instance=gcby-live-gdb-m1 --project=gcp-gcby
# 결과: root, gcby_app_user ✅
```

---

## 커밋 이력

### Commit: bc49084
**메시지**: 초기 users/databases 추가 (이후 리팩토링)
**변경사항**:
- terraform.tfvars에 database/user 수동 추가 (후에 locals로 대체됨)

### Commit: 314197e
**메시지**: Dynamic database/user naming using locals and project_name
**변경사항**:
- `environments/LIVE/gcp-gcby/60-database/main.tf`: locals 추가 (databases_auto, users_auto)
- `environments/LIVE/gcp-gcby/60-database/variables.tf`: db_root_password, db_app_password 추가
- `environments/LIVE/gcp-gcby/60-database/terraform.tfvars`: databases/users 빈 배열로 변경
- `proj-default-templet/60-database/*`: 모든 변경사항 템플릿 동기화

### Commit: 381bda8
**메시지**: Lifecycle ignore_changes for password management
**변경사항**:
- `modules/cloudsql-mysql/main.tf`: google_sql_user에 lifecycle 블록 추가
- `proj-default-templet/60-database/*`: 템플릿 동기화

### Commit: 0d6c42f
**메시지**: 테스트
**변경사항**:
- 최종 테스트 및 검증

---

## 영향을 받은 파일

### 모듈 파일
- `modules/cloudsql-mysql/main.tf`
  - google_sql_user에 lifecycle ignore_changes 추가

### 환경 파일
- `environments/LIVE/gcp-gcby/60-database/main.tf`
  - locals에 databases_auto, users_auto, databases_final, users_final 추가
- `environments/LIVE/gcp-gcby/60-database/variables.tf`
  - db_root_password, db_app_password 변수 추가
- `environments/LIVE/gcp-gcby/60-database/terraform.tfvars`
  - databases, users 빈 배열로 변경 (주석 추가)

### 템플릿 파일
- `proj-default-templet/60-database/main.tf`
- `proj-default-templet/60-database/variables.tf`
- `proj-default-templet/60-database/terraform.tfvars`

---

## 학습 및 개선 사항

### Terraform Best Practices
1. **Locals vs Variables**
   - tfvars에서는 변수 참조 불가
   - 동적 생성은 main.tf의 locals 사용

2. **Password 관리**
   - `lifecycle { ignore_changes }` 패턴은 업계 표준
   - Write-Only 속성은 최신 기능이지만 현행 유지

3. **DRY 원칙**
   - 프로젝트명 한 곳에서 정의, 여러 곳에서 재사용
   - 자동 생성 + 수동 추가 조합 패턴

### PSC 아키텍처 이해
1. **Global Access의 의미**
   - 단일 PSC FR이 모든 리전 서빙 가능
   - Cross-Region 연결 지원

2. **스케일링 전략**
   - 리전별 Cloud SQL → 리전별 PSC FR
   - 프로젝트별 Cloud SQL → IP만 추가 할당

---

## 다음 단계

### 즉시 수행
- ✅ Jenkins apply로 database/user 생성 완료
- ✅ DBeaver 연결 검증 완료

### 향후 계획
1. **Secret Manager 통합** (우선순위: 중)
   - 패스워드를 Secret Manager로 마이그레이션
   - State 파일에서 패스워드 제거

2. **password_wo 마이그레이션** (우선순위: 하)
   - 최신 Write-Only 속성 적용 검토

3. **IAM Database Authentication** (우선순위: 하)
   - 패스워드 기반 → IAM 기반 인증 전환 검토

---

## 참고 자료

### Terraform Documentation
- [google_sql_user Resource](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/sql_user)
- [Terraform Lifecycle Meta-Arguments](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle)
- [How to Use Ignore_Changes in Terraform Lifecycle](https://spacelift.io/blog/terraform-ignore-changes)

### Stack Overflow References
- [Creating Cloud SQL User with Terraform](https://stackoverflow.com/questions/52688448/creating-a-google-sql-user-with-terraform-always-recreates-the-resource)
- [Terraform Azure SQL Password Management](https://stackoverflow.com/questions/65143585/terraform-azure-sql-server-admin-password-change-forces-recreating-of-resource)

### GCP Documentation
- [Manage users with built-in authentication](https://cloud.google.com/sql/docs/mysql/create-manage-users)
- [gcloud sql users set-password](https://cloud.google.com/sdk/gcloud/reference/sql/users/set-password)

---

## 요약

### 완료된 작업
- ✅ PSC Global Access 검증 및 Cross-Region 연결 테스트
- ✅ Multi-Region/Multi-Project PSC 스케일링 전략 수립
- ✅ Cloud SQL Database/User 자동 네이밍 구현
- ✅ Password Lifecycle 관리 (ignore_changes) 구현
- ✅ Terraform Best Practice 리서치 및 검증
- ✅ DBeaver SSH 터널 연결 성공

### 생성된 리소스
- `gcby_gamedb` (Database)
- `root` (User)
- `gcby_app_user` (User)

### 핵심 성과
1. **자동화 향상**: 프로젝트명 기반 자동 리소스 생성
2. **운영 편의성**: 패스워드 수동 변경 허용 (Terraform이 되돌리지 않음)
3. **확장성**: 모든 신규 프로젝트에 자동 적용 (템플릿 동기화 완료)
4. **검증된 패턴**: 업계 표준 best practice 적용
